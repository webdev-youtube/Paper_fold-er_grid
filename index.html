<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Paper Folding & Grid Simulator</title>
<style>
    body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #f5f5f5;
        margin: 0;
        padding: 0;
    }
    h2 {
        margin-top: 10px;
        text-align: center;
    }
    .mode-toggle {
        margin: 10px 0;
        display: flex;
        gap: 10px;
        justify-content: center;
    }
    .stats {
        margin-top: 10px;
        text-align: center;
        font-size: 14px;
    }
    .paper-container {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 10px;
        background: #ddd;
        padding: 10px;
        border-radius: 10px;
        width: 90vw;
        height: 60vh;
        box-sizing: border-box;
    }
    .paper {
        background: white;
        border: 1px solid #ccc;
        border-radius: 5px;
        position: relative;
    }
    canvas {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
    }
    .fold-btn {
        position: absolute;
        background: rgba(0,0,0,0.3);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        cursor: pointer;
        user-select: none;
        transition: background 0.2s;
        z-index: 2;
    }
    .fold-btn:hover {
        background: rgba(0,0,0,0.5);
    }
    .fold-left { left: 5px; top: 50%; transform: translateY(-50%); }
    .fold-bottom { bottom: 5px; left: 50%; transform: translateX(-50%); }
    .controls {
        margin-top: 10px;
        display: flex;
        gap: 10px;
        justify-content: center;
    }
    button {
        padding: 5px 10px;
        font-size: 14px;
        cursor: pointer;
    }
    select, input {
        padding: 5px;
        font-size: 14px;
        margin: 3px;
    }
    .centered {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
    }
</style>
</head>
<body>

<h2>Paper Folding & Grid Simulator</h2>

<div class="mode-toggle">
    <button onclick="setMode('folding')">Folding Mode</button>
    <button onclick="setMode('grid')">Grid Mode</button>
</div>

<div id="folding-controls">
    <div class="centered">
        <select id="paperSelect"></select>
    </div>
</div>

<div id="grid-controls" style="display:none;">
    <div class="centered">
        <select id="gridPaperSelect"></select>
    </div>
    <div class="centered">
        <select id="gridSubMode">
            <option value="byCells">By Rows & Columns</option>
            <option value="bySize">By Cell Size</option>
        </select>
    </div>
    <div class="centered" id="gridByCells">
        Rows: <input type="number" id="rows" value="5" min="1">
        Columns: <input type="number" id="cols" value="5" min="1">
    </div>
    <div class="centered" id="gridBySize" style="display:none;">
        Cell Width (mm): <input type="number" id="cellWidth" value="20" min="0.1" step="0.1">
        Cell Height (mm): <input type="number" id="cellHeight" value="20" min="0.1" step="0.1">
    </div>
    <div class="centered">
        <button onclick="updateGrid()">Update Grid</button>
    </div>
</div>

<div class="stats" id="stats"></div>

<div class="paper-container">
    <div class="fold-btn fold-left" id="foldLeft" onclick="fold('left')">⇆</div>
    <div class="fold-btn fold-bottom" id="foldBottom" onclick="fold('bottom')">⇅</div>
    <div class="paper" id="paper"></div>
    <canvas id="gridCanvas"></canvas>
</div>

<div class="controls" id="folding-buttons">
    <button onclick="undo()">Undo</button>
    <button onclick="redo()">Redo</button>
</div>

<script>
const paperTypes = [
    { name: "A0 (84.1 × 118.9 cm)", width: 841, height: 1189, thickness: 0.1 },
    { name: "A1 (59.4 × 84.1 cm)", width: 594, height: 841, thickness: 0.1 },
    { name: "A2 (42 × 59.4 cm)", width: 420, height: 594, thickness: 0.1 },
    { name: "A3 (29.7 × 42 cm)", width: 297, height: 420, thickness: 0.1 },
    { name: "A4 (21 × 29.7 cm)", width: 210, height: 297, thickness: 0.1 },
    { name: "Custom Size", custom: true }
];

let mode = 'folding';
let width, height, thickness, folds;
let history = [], redoStack = [];
let scale = 1;

function setMode(m) {
    mode = m;

    // Show/hide relevant controls
    document.getElementById('folding-controls').style.display = m === 'folding' ? 'block' : 'none';
    document.getElementById('grid-controls').style.display = m === 'grid' ? 'block' : 'none';
    document.getElementById('folding-buttons').style.display = m === 'folding' ? 'flex' : 'none';
    document.getElementById('foldLeft').style.display = m === 'folding' ? 'flex' : 'none';
    document.getElementById('foldBottom').style.display = m === 'folding' ? 'flex' : 'none';

    // Clear grid when leaving grid mode
    const canvas = document.getElementById('gridCanvas');
    if (m !== 'grid') {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    // Update display
    updatePaper();
}
function init() {
    const foldingSelect = document.getElementById("paperSelect");
    const gridSelect = document.getElementById("gridPaperSelect");
    paperTypes.forEach((p, i) => {
        let opt1 = document.createElement("option");
        opt1.value = i;
        opt1.textContent = p.name;
        foldingSelect.appendChild(opt1);
        let opt2 = document.createElement("option");
        opt2.value = i;
        opt2.textContent = p.name;
        gridSelect.appendChild(opt2);
    });

    foldingSelect.addEventListener("change", () => {
        const selected = paperTypes[foldingSelect.value];
        if (selected.custom) {
            const w = parseFloat(prompt("Enter width in cm:", "")) * 10;
            const h = parseFloat(prompt("Enter height in cm:", "")) * 10;
            const t = parseFloat(prompt("Enter thickness in mm:", ""));
            if (!isNaN(w) && !isNaN(h) && !isNaN(t)) loadPaper({ width: w, height: h, thickness: t });
        } else loadPaper(selected);
    });

    gridSelect.addEventListener("change", () => {
        const selected = paperTypes[gridSelect.value];
        if (selected.custom) {
            const w = parseFloat(prompt("Enter width in cm:", "")) * 10;
            const h = parseFloat(prompt("Enter height in cm:", "")) * 10;
            const t = parseFloat(prompt("Enter thickness in mm:", ""));
            if (!isNaN(w) && !isNaN(h) && !isNaN(t)) loadPaper({ width: w, height: h, thickness: t });
        } else loadPaper(selected);
    });

    document.getElementById('gridSubMode').addEventListener("change", e => {
        document.getElementById('gridByCells').style.display = e.target.value === 'byCells' ? 'block' : 'none';
        document.getElementById('gridBySize').style.display = e.target.value === 'bySize' ? 'block' : 'none';
    });

    loadPaper(paperTypes[0]);
}

function loadPaper(paper) {
    width = paper.width;
    height = paper.height;
    thickness = paper.thickness;
    folds = 0;
    history = [];
    redoStack = [];
    updatePaper();
}

function formatMeasurement(mm) {
    const units = [
        { unit: "km", value: 1e6 },
        { unit: "m", value: 1000 },
        { unit: "cm", value: 10 },
        { unit: "mm", value: 1 },
        { unit: "µm", value: 1e-3 }
    ];
    for (let u of units) {
        if (mm >= u.value) {
            return (mm / u.value).toFixed(2).replace(/\.?0+$/,"") + " " + u.unit;
        }
    }
    return mm + " mm";
}

function updatePaper() {
    const paperEl = document.getElementById("paper");
    const container = document.querySelector(".paper-container");
    const scaleW = container.clientWidth * 0.7 / width;
    const scaleH = container.clientHeight * 0.7 / height;
    scale = Math.min(scaleW, scaleH);
    const minSize = 20;
    paperEl.style.width = Math.max(width * scale, minSize) + "px";
    paperEl.style.height = Math.max(height * scale, minSize) + "px";

    document.getElementById("stats").textContent =
        `Width: ${formatMeasurement(width)} | Height: ${formatMeasurement(height)} | Thickness: ${formatMeasurement(thickness)} | Folds: ${folds}`;

    if (mode === 'grid') drawGrid();
}

function drawGrid() {
    const canvas = document.getElementById('gridCanvas');
    const paperEl = document.getElementById('paper');
    canvas.width = paperEl.clientWidth;
    canvas.height = paperEl.clientHeight;
    canvas.style.width = paperEl.style.width;
    canvas.style.height = paperEl.style.height;
    canvas.style.left = paperEl.offsetLeft + "px";
    canvas.style.top = paperEl.offsetTop + "px";
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle = "#ccc";
    ctx.lineWidth = 1;

    let rows, cols;
    if (document.getElementById('gridSubMode').value === 'byCells') {
        rows = parseInt(document.getElementById('rows').value);
        cols = parseInt(document.getElementById('cols').value);
    } else {
        const cellW = parseFloat(document.getElementById('cellWidth').value);
        const cellH = parseFloat(document.getElementById('cellHeight').value);
        cols = Math.floor(width / cellW);
        rows = Math.floor(height / cellH);
    }

    const cellPixelW = canvas.width / cols;
    const cellPixelH = canvas.height / rows;

    for (let i = 1; i < cols; i++) {
        ctx.beginPath();
        ctx.moveTo(i * cellPixelW, 0);
        ctx.lineTo(i * cellPixelW, canvas.height);
        ctx.stroke();
    }
    for (let j = 1; j < rows; j++) {
        ctx.beginPath();
        ctx.moveTo(0, j * cellPixelH);
        ctx.lineTo(canvas.width, j * cellPixelH);
        ctx.stroke();
    }
}

function fold(direction) {
    history.push({ width, height, thickness, folds });
    redoStack = [];
    if (direction === "left") width /= 2;
    else height /= 2;
    thickness *= 2;
    folds++;
    updatePaper();
}

function undo() {
    if (history.length > 0) {
        redoStack.push({ width, height, thickness, folds });
        let prev = history.pop();
        width = prev.width;
        height = prev.height;
        thickness = prev.thickness;
        folds = prev.folds;
        updatePaper();
    }
}

function redo() {
    if (redoStack.length > 0) {
        history.push({ width, height, thickness, folds });
        let next = redoStack.pop();
        width = next.width;
        height = next.height;
        thickness = next.thickness;
        folds = next.folds;
        updatePaper();
    }
}

function updateGrid() {
    updatePaper();
}

init();
</script>
</body>
</html>
